/*
一共有两部分内容，一个是a表示现有的数据，另外一个是b表示现在的粘贴板数据
所以： b <= a
所以： 我们可以认为 b带来了成倍的效率， 得到一半的数，再增加。并且所有的偶数都可以这么操作。
参考一个偶数： f(6) = f(3) + c + p = f(3) + 2
然而 f(6) = f(2) + c + p + p = f(2) + 3
同时 对于 f(6) = 最差的情况就是 c + (6 - 1) * p 也就是 6次。
想到二分的平衡最快。
以及： 15 = 3 * 5
是得到 5 c p p
还是得到 3 c p p p p

16 4 * 4 f(4) + c  + p * (4-1) = f(4) + 4
   2 * 8    f(8) + c + p = f(4) + c + p + c + p = f(4) + 4
       16

	   除到一半就可以了。

	   每一次粘贴之后 一定得到一个偶数。

	   想 9 = f(3) * c + p + p

	   f(27) = 3 * 9 = c + p + p + f(9) = 6 + f(3)

	   f(34) = 2 * 17 = f(17) + 2 = 19
	   现在看看奇数：
	   5
*/

// f(1) = 0
// f(2) = 2 (2,1)
// f(3) = 3 (f(2))
// f(4) = min()
// f(5) = min( f(4) + 1, f(3) + 2, +　n)

var tmp = map[int]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1, 23: 1, 29: 1, 31: 1, 37: 1, 41: 1, 43: 1, 47: 1, 53: 1, 59: 1, 61: 1, 67: 1, 71: 1, 73: 1, 79: 1, 83: 1, 89: 1, 97: 1, 101: 1, 103: 1, 107: 1, 109: 1, 113: 1, 127: 1, 131: 1, 137: 1, 139: 1, 149: 1, 151: 1, 157: 1, 163: 1, 167: 1, 173: 1, 179: 1, 181: 1, 191: 1, 193: 1, 197: 1, 199: 1, 211: 1, 223: 1, 227: 1, 229: 1, 233: 1, 239: 1, 241: 1, 251: 1, 257: 1, 263: 1, 269: 1, 271: 1, 277: 1, 281: 1, 283: 1, 293: 1, 307: 1, 311: 1, 313: 1, 317: 1, 331: 1, 337: 1, 347: 1, 349: 1, 353: 1, 359: 1, 367: 1, 373: 1, 379: 1, 383: 1, 389: 1, 397: 1, 401: 1, 409: 1, 419: 1, 421: 1, 431: 1, 433: 1, 439: 1, 443: 1, 449: 1, 457: 1, 461: 1, 463: 1, 467: 1, 479: 1, 487: 1, 491: 1, 499: 1, 503: 1, 509: 1, 521: 1, 523: 1, 541: 1, 547: 1, 557: 1, 563: 1, 569: 1, 571: 1, 577: 1, 587: 1, 593: 1, 599: 1, 601: 1, 607: 1, 613: 1, 617: 1, 619: 1, 631: 1, 641: 1, 643: 1, 647: 1, 653: 1, 659: 1, 661: 1, 673: 1, 677: 1, 683: 1, 691: 1, 701: 1, 709: 1, 719: 1, 727: 1, 733: 1, 739: 1, 743: 1, 751: 1, 757: 1, 761: 1, 769: 1, 773: 1, 787: 1, 797: 1, 809: 1, 811: 1, 821: 1, 823: 1, 827: 1, 829: 1, 839: 1, 853: 1, 857: 1, 859: 1, 863: 1, 877: 1, 881: 1, 883: 1, 887: 1, 907: 1, 911: 1, 919: 1, 929: 1, 937: 1, 941: 1, 947: 1, 953: 1, 967: 1, 971: 1, 977: 1, 983: 1, 991: 1, 997: 1}

func minSteps(n int) int {
	if n == 1 {
		return 0
	}
	if _, ok := tmp[n]; ok {
		return n
	}
	min := n
	for i := 2; i <= n/2; i++ {
		if n%i == 0 {
			j := n / i
			k := minSteps(j) + i
			if k < min {
				min = k
			}
		}
	}
	return min
}

func minSteps(n int) int {
	//n*n矩阵保存
	cache := make([][]int, n+1)
	for i := 0; i < n+1; i++ {
		cache[i] = make([]int, n+1)
	}
	cache[1][1] = 1

	answer := 0

	for j := 2; j < n+1; j++ {
		answer = 1000
		for k := 1; k < j; k++ {
			if j%k == 0 {
				cache[j][k] = cache[j-k][k] + 1
				if cache[j][k] < answer {
					answer = cache[j][k]
				}
			}
		}
		cache[j][j] = answer + 1
	}

	return answer
}

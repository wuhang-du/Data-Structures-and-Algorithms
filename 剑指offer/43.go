/*
n个骰子的点数。
把n个骰子扔在地上，所有骰子的上一面点数之和为s.
输入n,打印出现的概率。

超大型的斐波拉契数列。

递归与循环： 一般有递归的办法，循环也能出来。


思路：
dp[i][j]表示 第i次，和为j的次数。
dp[i][j] = dp[i-1][j-1...j-6]

dp[2][12] = dp[1][11] = dp[0,10...5]
			dp[1][10] = dp[0,9...4]

重复的计算已经看见了。

基于此：既然可以反着推，一样就可以正着上了。

=========================================

第一次： 1 2 3 4 5 6
第二次：   2 3 4 5 6 7
			3 4 5 6 7 8
			  4 5 6 7 8 9

累计下来就是每一次每个项可以出现的次数。

所以 第n次，要么是上次的n-1,n-2 之和，要么是 n+1时 s的位置。
*/

package main

func main() {

}
